# 자바의 정석

## 변수

- 하나의 값을 저장하는 메모리 공간
- 용도를 알기 쉬운 의미 있는 이름 사용
- 기본형(논리, 문자, 정수, 실수)과 참조형
- 상수(final, 변경 불가)와 리터럴(그 자체로 값을 의미)
- 문자열 리터럴은 new를 사용하지 않는 표현도 허용되며 덧셈 연산자 사용시 문자열로 변환 후 결합
- 형변환(타입 캐스팅, 변수 또는 상수 타입을 다른 타입으로 변환)
- 자동 형변환은 기존 값을 최대한 보존할 수 있는 타입으로 자동 형변환

## 연산자

- 연산자(연산 수행 기호)와 피연산자(연산 작업 대상, 변수, 상수, 리터럴, 수식)
- 연산자는 항상 결과값을 반환
- 식(expression, 연산자와 피연산자 조합하여 계산 표현)
- 평가(evaluation, 식을 계산하여 결과 얻는 것)
- 산술 변환(연산 전 피연산자 타입 일치를 위해 자동 형변환)
- == 연산자는 값을 비교하기 때문에 기본형은 저장된 값을, 참조형은 저장된 주소 값을 비교(같은 객체 가리키는지 비교), 참조형의 경우 값 비교시 equals 사용

## 조건문과 반복문

- if, switch(case, break, default)
- for, 향상된 for, while, do-while
- 이름 붙은 반복문(Label1:for ~ break Label1;)

## 배열

- 같은 타입의 여러 변수를 하나의 묶음으로 다룸, 연속적인 저장공간 사용
- 배열의 길이는 0일 수 있음, 배열 길이는 변경 불가
- 다차원 배열과 가변 배열(다차원 배열에서 마지막 차수의 길이를 다르게 생성)

## 객체지향 프로그래밍

- 객체지향언어(실세계를 컴퓨터로 옮김, 속성과 기능을 변수와 함수로 정의, 코드 재사용성, 관리 용이성, 신뢰성 높임)
- 클래스(객체를 정의, 데이터와 함수의 결합, 사용자 정의 타입)와 객체(실제로 존재하는 것)와 인스턴스(클래스로부터 만들어진 객체)
    - 속성(변수, 필드)과 기능(함수, 메소드)
    - JVM의 메모리 구조(메소드 영역(클래스 파일 분석하여 클래스 정보 저장 및 변수 생성), 힙(인스턴스 변수 생성), 호출 스택(메소드 작업에 필요한 메모리 공간 제공))
    - 참조형 매개변수(기본형 매개변수는 단순히 값만 전달하지만 참조형 매개변수는 주소를 전달하므로 값 쓰기도 가능)
    - 클래스 메소드(인스턴스와 관계 없는 메소드)와 인스턴스 메소드(인스턴스 변수와 관련된 작업 수행)
- 오버로딩(같은 이름의 메소드를 여러개 정의 가능)
    - 가변인자(매개변수 개수를 동적으로 지정, 내부적으로 배열 이용)
- 생성자(인스턴스 초기화 메소드, 오버로딩 가능, 연산자 new가 인스턴스를 생성하는 것)
- 초기화(기본값 -> 명시적 초기화(변수 선언과 동시에) -> (클래스 또는 인스턴스) 초기화 블록 순서로 초기화)
- 상속(기존 클래스 재사용하여 새로운 클래스 작성, is a 관계), 포함 관계(멤버 변수로 다른 클래스 타입의 참조 변수 선언, has a 관계)
    - Object 클래스(모든 클래스의 조상)
- 오버라이딩(상위 클래스에 정의된 메소드를 하위 클래스에서 재정의)
    - this(인스턴스 자신을 가리키는 참조 변수)와 super(상위 클래스에서 상속받은 멤버 참조할 때 사용되는 참조 변수)
- 패키지(클래스와 인터페이스의 묶음, 물리적으로 클래스 파일을 포함하는 하나의 디렉토리, 모든 클래스는 반드시 하나의 패키지에 속함)
    - import문(다른 패키지 클래스 사용할 때 클래스의 패키지를 미리 명시하여 패키지명 생략)
- 제어자(클래스, 변수, 메소드의 선언부에 사용되어 부가적인 의미를 부여)
- 다형성(여러 형태를 가질 수 있는 능력, 한 타입의 참조 변수로 여러 타입의 객체를 참조 가능)
    - 업캐스팅(하위->상위 타입), 다운캐스팅(상위->하위 타입), instanceof 연산자(형변환 가능 여부 확인)
    - 참조 타입과 관계없이 실제 인스턴스 메소드가 호출됨
- 추상클래스(추상메소드를 포함할 수 있는 미완성 클래스, 인스턴스 생성 불가)
    - 추상메소드(선언부만 있는 메소드, 하위 클래스에서 구현하도록 강제)
- 인터페이스(추상 메소드와 상수만을 멤버로 가지는 일종의 추상 클래스, 다중 상속 가능)
    - 개발시간 단축, 표준화, 클래스간 관계 형성, 독립적인 프로그래밍
- 내부 클래스(클래스 내에 선언된 클래스, 외부 클래스의 멤버에 쉽게 접근, 캡슐화(불필요한 클래스 감춤))
    - 익명 클래스(클래스 선언과 객체 생성 동시에 하여 한번만 사용되는 일회용 클래스)

## 예외처리

- 컴파일 에러, 런타임 에러, 로지컬 에러
- 에러(복구 불가능한 심각한 오류)와 예외(코드에 의해 수습될 수 있는 미약한 오류)
- Exception(외적 요인, 사용자의 실수, checked(예외처리 강제))과 RuntimeException(프로그래머의 실수, unchecked)
- 예외를 던지는 메소드에는 선언부에 throws를 이용하여 Exception 예외를 작성
- finally 내에 return이 있을 경우 해당 값이 반환
- try-with-resources문(자동 자원 반환, AutoCloseable 인터페이스 구현 필요)
- 상속이 아닌 연결된 예외를 통해 여러 예외를 큰 분류의 예외로 묶어서 다를 수 있음

## java.lang 패키지와 유용한 클래스

- Object 클래스(모든 클래스의 조상, clone, equals, finalize, getClass, hashCode, toString, notify, notifyAll, wait)
- String 클래스(변경 불가능한 문자열 클래스, 연산자 +로 결합하면 매번 새로운 문자열생성 -> 결합 횟수 줄이거나 StringBuffer 사용 권장)
- StringBuffer 클래스(버퍼로 문자열 변경이 가능한 클래스, 멀티스레드에 안전하지 않음)
- Math 클래스(상수 E/PI, 올림/반올림/버림, ~Exact(오버플로우에 에외 발생), 삼각함수, 지수, 로그, StrictMath(모든 OS에서 같은 결과))
- Wrapper 클래스(기본형 변수가 객체로 다뤄질 필요가 있을 때 사용, 오토박싱(기본형 -> 래퍼), 언박싱(래퍼 -> 기본형)
- Objects 클래스(Object 클레스의 보조 클래스, 객페 비교와 널 체크에 유용)
- Random 클래스(난수 획득, Math.random()도 내부적으로 이 Random 클래스 사용)
- 정규식(텍스트 데이터를 원하는 조건과 일치하는 문자열 찾기 위해 사용)
- Scanner 클래스(입력 소스에서 문자 데이터 읽어오는 클래스(정규식 검색 가능, ㅇ구분자 단위 입력 가능))
- StringTokenizer 클래스(문자열을 구분자로 여러 개의 토큰으로 문자열 골라서 잘라주는 클래스, 빈 문자열은 토큰으로 인식하지 않음)
- BigInteger 클래스(long 보다 큰 정수형 값 다루는 클래스), BigDecimal 클래스(double 보다 더 정밀한 실수형 값 다루는 클래스)

## 날짜와 시간

- Calendar(추상 클래스로 getInstance 메소드로 인스턴스 획득)와 Date(특정 순간을 밀리초 단위로 나타내는 클래스, Calendar, DateFormat 클래스 사용이 권장됨)
- LocalDate, LocalTime, LocalDateTime, Instant(에포크 타임에서 경과된 시간을 나노초 단위로 표현)
- TemporalAdjusters(날짜 계산 대신해주는 메소드 정의해놓은 클래스)
- Period(날짜의 차이)와 Duration(시간의 차이)

## 컬렉션 프레임워크

- 다수의 데이터를 저장하는 클래스를 위한 표준화된 프로그래밍 방식
- Collection 인터페이스(List와 Set의 조상, 데이터 읽기 추가 삭제 등 메소드 제공)
- List(순서가 있으며 데이터 중복을 허용하는 데이터 집합)
    - ArrayList, LinkedList, Vector
- Set(순서가 없고 데이터 중복을 허용하지 않는 데이터 집합)
    - HashSet, SortedSet
- Map(순서가 없고 값 중복을 허용하는 키와 값의 쌍으로 이루어진 데이터 집합)
    - Hashtable, HashMap, SortedMap
- ArrayList(백터를 개선한 동적 배열)
- LinkedList(불연속 데이터를 연결한 형태의 컬렉션, Queue, Deque 인터페이스 구현)
- Stack(마지막에 들어간 것이 먼저 나오는 컬렉션, 배열로 구현 적합)
- Queue(처음에 들어간 것이 먼저 나오는 컬렉션, 연결 리스트로 구현 적합, 큐는 인터페이스로 구현한 클래스(LinkedList) 사용)
- PriorityQueue(우선 순위가 높은 항목이 먼저 나오는 컬렉션, 힙으로 구현 적합)
- Deque(양 끝에 추가/삭제가 가능, 덱은 인터페이스로 구현한 클래스(ArrayDeque, LinkedList) 사용)
- HashSet(해싱을 통해 구현된 중복 허용하지 않고 순서가 없는 컬렉션)
- TreeSet(이진 검색 트리 형태로 데이터를 저장하는 컬렉션, 레드-블랙 트리로 구현)
- HashMap(해싱을 사용하여 키와 값을 묶어 하나의 데이터(엔트리)로 저장하는 컬렉션)
- TreeMap(이진 검색 트리 형태로 키-값 쌍 데이터를 저장하는 컬렉션, 범위검색, 정렬에 사용)
- Properties(String 키-값 쌍 데이터를 저장하는 컬렉션, 환경설정 저장에 사용)

- Enumeration(이터레이터 이전에 사용하던 클래스), Iteration(컬렉션에 저장된 각 요소에 접근), ListIteration(양방향 조회가 가능한 이터레이터)
- Arrays(배열 관련 메소드 제공)와 Collections(컬렉션 관련 메소드 제공)
- Comparator(별도 기준으로 정렬)와 comparable(해당 클래스의 기본 정렬 기준 구현)

## 지네릭스, 열거형, 애너테이션

- 지네릭스(다양한 타입의 객체를 다루는 메소드, 컬렉션 클래스에 컴파일시 타입 체크 해주는 기능, 타입 안정성 높이고 형변환의 번거로움 줄임)
    - static 멤버에 사용 불가, 제네릭 타입 배열 생성 불가, instanceof 연산자 사용 불가
    - 와일드 카드를 사용한 상한과 하한 제한 \<? extends T\>(T와 그 자손만), \<? super T\>(T와 그 조상만)
    - 대입된 타입이 다른 지네릭 타입(Box\<A\>, Box\<B\>)간에는 변환이 불가능(Object 타입도 불가)
    - 이전 코드(1.5 미만)와의 호환성을 위해 원시 타입을 사용한 코드 작성을 허용하며 컴파일러가 지네릭 타입으로 소스 파일을 체크하여 형변환을 넣어주고 지네릭 타입을 모두 제거
- 열거형(서로 관련된 상수를 묶어 선언, 타입에 안전)
    - 열거형 상수 하나하나는 사실 해당 객체(==으로 비교 가능하고 추상 메소드를 선언하면 구현해야 함)
- 애너테이션(소스코드 안에 다른 프로그램을 위한 정보를 약속된 형식으로 포함시킨 것)
    - 표준 애너테이션과 메타 애너테이션(애너테이션에 붙이는 애너테이션)

## 쓰레드

- 프로세스(실행에 필요한 자원을 할당받아 실행 중인 프로그램)
- 쓰레드(프로세스의 자원을 이용하여 실제 작업을 수행)
- 모든 프로세스는 하나 이상의 스레드 소유, 둘 이상인 경우 멀티쓰레드 프로세스라 함
- 멀티태스킹(여러 개의 프로세스가 동시에 실행)
- 멀티쓰레딩(하나의 프로세스 내에 여러 쓰레드가 동시에 작업 실행)
    - 장: CPU 사용률 향상, 자원의 효율적 사용, 사용자 응답성 향상, 작업을 분리하여 코드 간결하게 유지
    - 단: 동기화, 교착상태(데드락), 작업 합치기 필요
- Thread 클래스 상속 또는 Runnable 인터페이스 구현, start()를 호출하여 쓰레드 실행
    - start는 새로운 쓰레드가 작업을 실행하는데 필요한 호출 스택을 생성한 다음 run을 호출하여 생성된 호출 스택에 첫번째로 올라가게 함
    - 새 쓰레드 생성하여 실행시킬 때마다 새로운 호출 스택이 생성되고 쓰레드 종료시 작업에 사용된 호출 스택이 소멸
    - 여러 개의 호출 스택은 스케줄러가 정한 순서에 따라 번갈아 가며 실행
- 데몬 쓰레드: 일반 쓰레드의 작업을 돕는 보조 역할 수행하는 쓰레드(Ex: 가비지 컬렉터, 자동 저장, 화면 자동 갱신), 일반 쓰레드 종료시 강제 자동 종료
- 쓰레드의 상태: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
- 쓰레드 스케줄링 관련 메소드: sleep, interrupt, interrupted, suspend, resume, stop, yield, join
- 쓰레드 동기화(한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것)
    - synchronized(메소드 전체 또는 특정 블록을 임계 영역으로 지정, 락을 통해 작업 수행)
    - wait와 notify(특정 쓰레드가 객체의 락을 가지고 오랜 시간 소모하는 상황 방지, wait로 일단 락 반납하고 진행할 수 있는 상황이 되면 notify로 락을 얻어 작업 진행)
    - Lock과 Condition(synchronized block은 다른 곳에서의 값의 변경을 막을 수 없음, 수동으로 락 잠그고 해제 필요)
    - volatile(메모리에서 값을 읽어와 캐시와 메모리간 값의 불일치 문제 해결, long과 double의 원자화 가능)
    - fork와 join 프레임워크(하나의 작업을 작은 단위로 나누어 여러 쓰레드가 동시에 처리하기 쉽게 만들어줌, 쓰레드 풀 이용)

## 람다와 스트림

- 람다식(메소드를 하나의 식으로 표현, 익명 함수, 매개변수로 전달하거나 결과로 반환 가능)
  - 함수형 인터페이스(람다식을 다루기 위한 하나의 추상 메소드만 정의된 인터페이스)
  - java.util.function 패키지에는 자주 사용되는 형식의 메소드를 함수형 인터페이스로 미리 정의
  - 하나의 메소드만 호출하는 람다식은 클래스명::메소드명 또는 참조변수::메소드명으로 변환 가능
- 스트림(데이터 소스를 추상화하여 같은 방식으로 다룰 수 있게 하여 코드의 재사용성을 높임)
  - 데이터 소스 변경 X, 일회용, 작업을 내부 반복으로 처리
  - 중간 연산(연산 결과가 스트림)과 최종 연산(연산 결과가 스트림이 아님, 스트림 요소 소모하므로 한번만 가능)
  - 지연된 연산(최종 연산 실행 전까지 중간 연산은 실행되지 않음)
  - collect(스트림의 요소를 수집하거나 컬렉터로 요소 수집 방법 정의, Collectors 클래스에서 미리 작성된 컬렉터를 제공, 통계/리듀싱/문자열 결합/그룹화와 분할 가능)

## 입출력

- 컴퓨터 내부 또는 외부 장치와 프로그램 간에 데이터 주고받는 것
- 스트림(데이터 운반에 사용되는 연결통로, 단방향 통신으로 입력과 출력에 스트림 각각 필요, FIFO 구조)
- 바이트기반 스트림(InputStream, OutputStream)과 문자기반 스트림(Reader, Writer)
- 보조스트림(스트림 기능 향상, 새로운 기능 추가, 입출력 기능은 없으므로 스트림 먼저 생성해야)
- 표준입출력(콘솔을 통한 데이터 입출력, 앱 실행과 동시에 자동 생성, 버퍼 이용)
- File(파일과 디렉토리 다루는 클래스)
- 직렬화(객체를 데이터 스트림으로 만드는 것, 객체에 저장된 데이터를 스트림에 쓰기 위해 연속적인 데이터로 변환)

## 네트워킹

- 두 대 이상의 컴퓨터 연결하여 네트워크 구성, 데이터 전달과 주변기기 공유 목적
- java.net 패키지로 네트워크 앱 작성 가능
- 서버 기반 모델과 P2P 모델
- IP 주소(컴퓨터를 구별하는데 사용되는 고유한 값)와 InetAddress(IP 주소 다루는 클래스)
- URL(인터넷에 존재하는 서버에서 제공하는 자원에 접근할 수 있는 주소 표현, 프로토콜://호스트명:포트번호/경로명/파일명?쿼리스트링#참조)
- URLConnection(앱과 URL간의 통신 연결을 나타내는 최상위 추상 클래스, 구현된 클래스로 HttpURLConnection이 있음)
- 소켓(프로세스간 통신에 사용되는 양쪽 엔드포인트) 프로그래밍
  - TCP(연결 기반 클라이언트-서버 간의 1:1 통신 방식의 바이트스트림을 이용한 신뢰성 있는 데이터 전송)
  - UDP(비연결 기반 데이터그램을 이용한 신뢰성 없는 빠른 데이터 전송)