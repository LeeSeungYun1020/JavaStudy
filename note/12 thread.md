# 쓰레드

## 프로세스와 스레드

- 프로세스: 실행에 필요한 자원(메모리)을 할당받아 실행 중인 프로그램
- 쓰레드: 프로세스의 자원을 이용해서 실제 작업을 수행하는 것
- 모든 프로세스는 하나 이상의 쓰레드 가지며 둘 이상의 쓰레드 가진 프로세스를 멀티쓰레드 프로세스라 함
- 멀티태스킹: 여러 개의 프로세스가 동시에 실행
- 멀티쓰레딩: 하나의 프로세스 내에서 쓰레드가 동시에 작업 실행
- 각 코어가 아주 짧은 시간 동안 여러 작업을 번갈아 수행하여 동시에 수행되는 것처럼 보이게 함

### 멀티스레딩의 장단점

- 장: CPU 사용률 향상, 자원의 효율적 사용, 사용자 응답성 향상, 작업을 분리하여 코드 간결하게 유지
- 단: 동기화, 교착상태(데드락), 작업 합치기 필요

## 쓰레드 구현과 실행

- Thread 클래스 상속
- Runnable 인터페이스 구현
- Thread 클래스를 상속 받으면 다른 클래스 상속받지 못하기 때문에 Runnable 인터페이스 구현
- Runnable 인터페이스 구현시 Thread 생성자로 구현한 클래스의 인스턴스 전달하여 Thread 객체 획득하여 사용
- start()를 호출하여 쓰레드 실행
    - 실행 대기 상태에 있다가 자신의 차례가 되면 실행
    - 쓰레드 실행 순서는 운영체제의 스케줄러에 의해 결정
- 한 번 종료된 쓰레드는 재실행 불가 -> start() 재호출시 IllegalThreadStateException 발생

## start()와 run()

- 오버라이드한 run을 호출하는 것은 쓰레드 실행이 아닌 단순 메소드 호출
- start는 새로운 쓰레드가 작업을 실행하는데 필요한 호출 스택을 생성한 다음 run을 호출하여 생성된 호출 스택에 첫번째로 올라가게 함
- 쓰레드는 독립적인 작업 수행을 위해 자신만의 호출 스택이 필요
- 새 쓰레드 생성하여 실행시킬 때마다 새로운 호출 스택이 생성되고 쓰레드 종료시 작업에 사용된 호출 스택이 소멸
- 여러 개의 호출 스택은 스케줄러가 정한 순서에 따라 번갈아 가며 실행
- 프로그램을 실행하면 기본적으로 하나의 쓰레드를 생성하여 main 메소드를 호출
- 실행 중인 사용자 쓰레드가 하나도 없을 때 프로그램이 종료

## 싱글쓰레드와 멀티쓰레드

- Ex1: 두 개의 콘솔 출력 작업을 하나의 쓰레드로 처리 VS 두 개의 쓰레드로 처리
    - 두 쓰레드 간의 컨텍스트 스위칭으로 시간이 소요
    - 두 쓰레드가 화면(콘솔)에 출력하기 위해 경쟁
- 쓰레드는 OS 종속적 - 프로세스도 프로세스 스케줄러에 의해 실행 순서와 시간 결정되며 쓰레드에 할당되는 시간 역시 일정하지 않음
- Ex2: 입력 작업과 콘솔 출력 작업을 하나의 쓰레드로 처리 VS 두 개의 쓰레드로 처리
    - 한 쓰레드에서 처리할 경우 사용자가 입력할 때까지 콘솔 출력 작업 처리 불가(대기)
    - 멀티쓰레드는 서로 다른 자원 사용하는 작업에 효율적

## 쓰레드의 우선순위

- 쓰레드에는 우선순위 속성(멤버 변수)이 있으며 값에 따라 쓰레드가 얻는 실행 시간이 달라짐
- 멀티 코어에서는 우선순위에 따른 차이가 거의 없음 -> 작업에 우선순위 부여하여 우선순위 큐 사용하여 처리 권장

## 쓰레드 그룹

- 서로 관련된 쓰레드를 그룹으로 다룸
- 자신이 속한 쓰레드 그룹과 하위 쓰레드 그룹만 변경 가능
- 앱이 실행되면 JVM은 main, system 쓰레드 그룹을 만들고 운용에 필요한 쓰레드를 생성하여 이 쓰레드 그룹에 포함
    - main 메소드 수행하는 main 쓰레드는 main 그룹에 포함
    - 가비지 컬렉션 수행하는 Finalizer 쓰레드는 system 그룹에 포함
- 쓰레드 그룹을 지정하지 않은 쓰레드는 기본적으로 자신을 생성한 쓰레드와 같은 쓰레드 그룹에 속함
    - 생성한 모든 쓰레드 그룹은 main 쓰레드 그룹의 하위 쓰레드 그룹
    - 그룹을 지정하지 않고 생성한 쓰레드는 main 쓰레드 그룹에 속함

## 데몬 쓰레드

- 데몬 쓰레드가 아닌 일반 쓰레드의 작업을 돕는 보조 역할을 수행하는 쓰레드
- 일반 쓰레드가 모두 종료되면 강제 자동 종료(더 이상 필요 X)
- Ex: 가비지 컬렉터, 워드프로세서 자동 저장, 화면 자동 갱신 등
- setDaemon()으로 쓰레드 실행전 지정(이후 지정시 IllegalThreadStateException 발생)

## 쓰레드의 실행 제어

- 효율적인 멀티쓰레드 프로그램을 위해 정교한 스케줄링을 통해 프로세스의 자원과 시간을 여러 쓰레드가 낭비없이 잘 사용해야

### 쓰레드의 상태

- NEW: 쓰레드가 생성되고 start가 호출되지 않은 상태
- RUNNABLE: 실행 중, 실행 가능한 상태
- BLOCKED: 동기화 블록에 의해 일시정지된 상태(lock 풀릴 때까지 대기)
- WAITING: 쓰레드의 작업이 종료되지 않았지만 실행 가능하지 않은 일시정지 상태
- TIMED_WAITING: 일시정지 기간이 지정된 일시정지 상태
- TERMINATED: 쓰레드의 작업이 종료된 상태


- start 호출시 바로 실행되는 것이 아니라 실행대기열(큐)에 저장되어 대기
- 주어진 시간이 모두 소모되거나 yield를 만나면 실행대기상태가 되어 실행대기열에서 대기
- 실행 중 suspend(), sleep(), wait(), join(), I/O block에 의해 일시정지 상태로 변경
- 일시정지 중 time-out, notify(), resume(), interrupt()에 의해 실행대기상태가 되어 실행대기열에서 대기
- 실행이 끝나거나 stop이 호출되면 쓰레드 소멸

### 쓰레드 스케줄링 관련 메소드

- sleep: 일정시간동안 쓰레드 멈춤
    - 지정된 시간이 다되거나 interrupt() 호출시 실행대기 상태로 전환
    - try-catch로 예외처리 필요(interrupt 호출시 InterruptedException 발생)
    - sleep은 static 멤버로 현재 실행 중인 스레드에 대해 동작
- interrupt, interrupted: 쓰레드 작업 취소
    - 진행 중인 쓰레드 작업 종료 전 취소가 필요할 때, 쓰레드에 작업 종료 요청(강제 종료 X)
    - WAITING 상태에서 interrupt 호출시 RUNNABLE로 상태 변경되며 InterruptedException 발생
    - interrupt: 쓰레드의 interrupted 상태를 true로 변경
    - isInterrupted: 쓰레드의 interrupted 상태를 반환
    - interrupted: 현재 쓰레드의 interrupted 상태를 반환하며 false로 변경
- suspend, resume, stop: 쓰레드 정지, 재개, 중단
    - suspend로 정지된 쓰레드는 resumed으로 재개 가능
    - stop 호출 즉시 쓰레드 종료
    - suspend, stop이 데드락 발생 가능하므로 사용 권장 X
    - suspended, stopped를 별도의 인스턴스 변수로 선언하고 반복문과 조건문 정의하는 방법 권장됨

```java
boolean suspended=false;
        boolean stopped=false;
public void run(){
        while(!stopped){
        if(!suspended){
        // 작업 수행
        }
        }
        }
```

- yield: 다른 쓰레드에 양보
    - 주어진 실행시간을 다음 차례의 쓰레드에 양보
    - 응답성 높이고 효율적인 실행 가능하게 함
- join: 다른 쓰레드의 작업 기다림
    - 다른 쓰레드가 지정 시간(또는 종료)까지 작업을 수행하도록 함
    - try-catch로 예외처리 필요(interrupt 호출시 InterruptedException 발생)
    - 특정 쓰레드에 대해 동작

## 쓰레드 동기화

- 멀티쓰레드 프로세스에서 공유 데이터를 동시에 작업할 경우 문제 발생 가능
- 쓰레드 동기화: 한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것

### synchronized를 통한 동기화

- 메소드 전체 또는 특정 블록을 임계 영역으로 지정 가능
- 락을 얻어 작업 수행하고 종료시 락 반환
- 지정된 영역의 코드를 한 번에 한 쓰레드만 실행하는 것을 보장하는 것일 뿐
  다른 곳에서 값의 변경이 있다면 동기화 문제 발생 가능

### wait()와 notify()

- 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 소모하는 상황 방지 필요
- 더이상 작업을 진행할 수 없으면 일단 wait로 쓰레드가 락을 반납하고 기다리게 함
- 작업을 진행할 수 있는 상황이 되면 notify로 다시 락을 얻어 작업 진행
- 특정 객체에 대한 것으로 Object 클래스에 정의
- 동기화(synchronized) 블록 내에서만 사용 가능
- notifyAll로 모든 대기 중인 스레드에 통지 가능
- 특정 쓰레드를 선택해서 notify 불가능한 문제 존재(대기열의 임의의 쓰레드가 통지 받음)


- 기아 현상: 특정 쓰레드가 계속해서 통지받지 못하고 오랫동안 기다리게 되는 현상
- 경쟁 상태: 여러 쓰레드가 서로 락을 얻기 위해 경쟁하는 것

### Lock과 Condition을 이용한 동기화

- synchronized 블록은 같은 메소드 내에서만 락을 걸 수 있고 다른 곳에서 값의 변경을 막을 수 없음
- ReentrantLock: 재진입이 가능한 일반적인 배타적 lock
- ReentrantReadWriteLock: 읽기에는 공유적이고 쓰기에는 배타적인 lock
- StampedLock: ReentrantReadWriteLock에 낙관적인 lock 기능 추가
- Reentrant는 재진입 가능한이라는 의미로 특정 조건에서 락을 풀고 나중에 다시 락을 얻어 작업 실행 가능
- ReadWriteLock은 읽기 락이 걸리면 읽기만 가능(중복 가능)하고 쓰기 락이 걸리면 대기해야하는 락
- 낙관적인 락은 쓰기와 읽기가 충돌하면 쓰기가 끝난 후 읽기 락을 거는 락

#### ReentrantRock

- 생성자는 공정하게(가장 오래 기다린 쓰레드가 실행되게) 처리할 것인지 매개변수로 전달 가능
- synchronized 블록과 달리 수동으로 락 잠그고 해제 필요(lock, unlock 메소드)
- 임계 영역 내에서 예외 또는 return할 경우 락이 풀리지 않을 수 있으므로 try-finally문으로 감싸 unlock 호출
- tryLock()으로 락을 얻지 못하면 기다리지 않도록 하여 응답성 개선 가능
- Condition을 생성하고 await(), signal() 메소드로 쓰레드 종류에 따라 구분하여 통지 가능

### volatile

- 멀티 코어 프로세서에서는 코어별로 별도의 캐시 보유
- 메모리에서 읽어온 값을 캐시에 저장하고 캐시에서 값을 얻어 작업하므로 동기화 문제 발생 가능
- volatile 변수는 메모리에서 값을 읽어와 캐시와 메모리간 값의 불일치 문제 해결
- synchronized 블록 들어갈 때와 나갈 때 캐시-메모리간 동기화가 이루어지기 때문에 synchronized 메소드로 값 읽기/쓰기시 같은 효과
- long, double은 하나의 명령어로 값을 읽거나 쓸 수 없기 때문에 변수 읽는 중 다른 쓰레드가 끼어들 수 있음 -> volatile로 원자화 가능

### fork와 join 프레임워크

- 하나의 작업을 작은 단위로 나눠서 여러 쓰레드가 동시에 처리하기 쉽게 만들어주는 프레임워크
- 쓰레드 풀: 지정된 수의 쓰레드를 미리 생성해서 만들어 두고 반복해서 재사용, 쓰레드가 수행해야 할 작업을 담은 큐를 제공하여 순서대로 처리
    - 쓰레드풀은 작업 큐가 비어있는 쓰레드가 다른 쓰레드의 작업 큐에 있는 작업을 가져와 수행하도록 함(work stealing) -> 여러 쓰레드가 작업 골고루 나눠서 처리
- 반환값이 있는 작업은 RecursiveTask, 없는 작업은 RecursiveAction 상속 받아 구현 가능
    - 두 클래스 모두 추상 메소드인 compute() 구현 필요
    - compute에서는 수행할 작업과 작업을 어떻게 나눌지를 알려줘야 함
    - fork(): 해당 작업을 쓰레드 풀의 작업 큐에 넣음 (비동기 메소드, 결과 대기하지 않음)
    - join(): 해당 작업의 수행이 끝날 때까지 기다렸다가 수행이 끝나면 결과 반환 (동기 메소드, 결과 대기)
- 멀티 쓰레드 처리가 항상 더 빠른 것은 아니므로 이득이 있을 때만 사용해야