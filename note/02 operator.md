# 연산자
## 연산자
### 연산자와 피연산자
- 연산자: 연산을 수행하는 기호
- 피연산자: 연산자의 작업 대상(변수, 상수, 리터럴, 수식)
- 연산자는 피연산자로 연산을 수행 후 항상 결과값 반환

### 식과 대입연산자
- 식(expression): 연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것
- 평가(evaluation): 식을 게산하여 결과를 얻는 것, 식을 평가하면 하나의 결과를 얻음
- 예를 들어 4 * x + 3;이라는 식은 평가되어 결과를 얻었지만 사용되지 않음 -> 대입 연산자를 사용하여 결과 저장 가능

### 연산자의 종류
- 산술, 비교, 논리, 대입 연산자가 존재
- 피연산자 개수에 따라 단항, 이항, 삼항 연산자가 존재

### 연산자 우선순위와 결합규칙
- 괄호 안의 계산식이 가장 먼저 수행, 괄호는 연산자가 아님!
- 식에 같은 우선순위의 연산자가 여러 개 있는 경우 결합규칙에 따라 처리
- 산술 -> 비교 -> 논리 -> 대입 순서
- 단항 -> 이항 -> 삼항 순서
- 단항, 대입 연산자 외 모든 연산의 진행 방향은 왼쪽에서 오른쪽

### 산술 변환
- 연산 전에 피연산자 타입 일치를 위해 자동 형변환되는 것
- 두 피연산자의 타입을 큰 타입으로 같게 일치시킴
- 피연산자 타입이 int보다 작은 타입이면 int로 변환

## 단항 연산자
### 증감 연산자 ++ --
- 증감 연산자는 피연산자의 값을 변경
- 값이 참조되기 전, 후에 참조되느냐에 따라 앞에 위치한 전위형, 뒤에 위치한 후위형으로 나뉨
- 식에 두 번 이상 포함된 변수에 증감연산자 사용하는 것은 피해야 함

### 부호 연산자 + -
- -는 부호를 반대로 한 결과 반환
- boolean, char 제외한 기본형에만 사용 가능

## 산술 연산자
### 사칙 연산자 + - * /
- *, /, %가 +, - 보다 먼저 처리
- 정수형인 경우 0으로 나누기 불가
- int / int는 int 반환, 소수점 이하 버림
- 산술 변환 규칙에 따라 byte + byte의 결과는 int이며 byte 변수에 사용하기 위해 형변환이 필요
- int * int는 int 반환 -> long 변수에 대입하더라도 값은 변하지 않으므로 큰 값의 바른 게산을 위해 형변환 필요
- 리터럴 간의 연산은 컴파일러가 컴파일 시에 미리 계산

### 나머지 연산자 %
- 왼쪽 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값 결과로 반환
- 나누는 수로 0 불가

## 비교 연산자
### 대소비교 연산자 < > <= >=
- boolean을 제외한 기본형에 사용 가능

### 등가비교 연산자 == !=
- 기본형인 경우 변수에 저장되어 있는 값이 같은지 비교
- 참조형의 경우 두 개의 참조 변수가 같은 객체를 가리키는지 비교
- 실수형 비교시 항상 유의해야 (Ex: 0.1과 0.1f) -> double을 float로 형변환 후 비교 또는 특정 자리까지만 비교
- 문자열 비교시 equals 사용
- wrapper 클래스 비교시 equals 사용

## 논리 연산자
### 논리 연산자 && || !
- &&: and, ||: or, !: not
- 하나의 식에 &&와 ||가 함께 포함된 경우 괄호 명시하는 것 권장
- short circuit evaluation: 좌측 피연산자 값만으로 평가가 가능한 경우 우측 파연산자 평가하지 않음

### 비트 연산자 & | ^ ~ << >>
- &: and, |: or, ^: xor, ~: not(1의 보수, <</>>: shift

### 조건 연산자 ? :
- 조건식 ? 식1(참인 경우) : 식2(거짓인 경우)

### 대입 연산자 = op=
- 변수 같이 저장공간에 값 또는 수식의 결과 저장하는데 사용
- 저장된 값을 연산 결과로 반환(중첩 가능)
- 대입 연산자의 왼쪽 피연산자를 lvalue, 오른쪽 피연산자를 rvalue라 함
- lvalue는 변수 같이 값을 변경할 수 있는 것이어야 함
- 복합 대입 연산자: 다른 연산자와 대입 연산자를 결합하여 사용